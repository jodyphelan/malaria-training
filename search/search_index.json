{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Malaria genomics learning","text":"<p>This is a collection of resources for learning about malaria genomics. It is intended for researchers who are new to the field and want to learn more about the genomics of malaria parasites.</p>"},{"location":"#introduction","title":"Introduction","text":"<p>Malaria is a disease caused by parasites of the genus Plasmodium. The most severe form of malaria is caused by Plasmodium falciparum, which is responsible for the majority of malaria-related deaths. Malaria is transmitted to humans through the bites of infected mosquitoes. The parasites then multiply in the liver and red blood cells, leading to the symptoms of the disease. One of the major challenges in treating malaria is the emergence of drug resistance. This is particularly problematic in the case of P. falciparum, which has developed resistance to multiple antimalarial drugs. Detecting drug resistance mutations in the parasite's genome can help guide treatment decisions and prevent the spread of resistance.</p>"},{"location":"#learning-objectives","title":"Learning objectives","text":"<p>By the end of this course, you will be able to:</p> <ul> <li>Use the command line to run malaria-profiler on next-generation sequencing data of P. falciparum isolates</li> <li>Analyse the results of a malaria-profiler run to identify drug resistance mutations</li> <li>Use pyMoi to characterise the polygenomic patterns of P. falciparum isolates</li> </ul>"},{"location":"#dataset","title":"Dataset","text":"<p>We will be using data from a study that sequenced the genomes of P. falciparum isolates from Mozambique. The dataset consists of whole-genome sequencing data for multiple isolates collected from different regions of the country. We will use this data to identify genetic variants associated with drug resistance and population structure in the parasite population. Have a look at the paper here. To reduce the size of the dataset, we will focus on a subset of isolates. We have also reduced the amount of data (taking only reads overlapping drug resistance genes and some other key regions) for each isolate to make the analysis more manageable. The dataset is available for download here. </p> <p>Important</p> <p>Bioinformatics takes time! There will be several times during the practical where you will be waiting for commands to finish running. This is normal and part of the process. If you have any questions or need help, please ask the instructors. This is also a good oppurtunity to find out more about how the data was generated. While you are waiting for commands to finish, you can read the paper linked above to learn more about the study.</p>"},{"location":"#malaria-profiler","title":"Malaria-Profiler","text":"<p>Malaria-Profiler is a user-friendly tool that can rapidly and accurately predict the geographical regional source and anti-malarial drug resistance profiles across large numbers of samples with WGS data. The software is flexible with modifiable bioinformatic pipelines. For example, it is possible to select the sequencing platform, display specific variants, and customise the format of outputs. With the increasing application of next-generation sequencing platforms on Plasmodium DNA, Malaria-Profiler has the potential to be integrated into point-of-care and surveillance settings, thereby assisting malaria control. Malaria-Profiler is available online (https://bioinformatics.lshtm.ac.uk/malaria-profiler) and as standalone software (https://github.com/jodyphelan/malaria-profiler). We will be using the standalone version for this course.</p> <p>First we need to get the data that we will be using for this practical.</p> <pre><code>git clone https://github.com/jodyphelan/malaria-demo-data.git\n</code></pre> <p>After the command has finished running, please move in to the folder you just downloaded. You will now have several input files we will use during the practical. This includes:</p> <ul> <li>Fastq files</li> <li>Pre-generated result files</li> </ul> <p>We will then need to install malaria-profiler. We can do this by first creating a conda environment that will contain all requred software. We can do this with conda by downloading all the prerequiste dependancies. We have prepared a file that contains all this information which conda will be able to read and create the environment for you.</p> <pre><code>conda create --file data_files/conda_env.txt --name malaria-profiler\n</code></pre> <p>Now that we have all the dependancies installed we will need to install malaria-profiler. We can use the python package manager <code>pip</code> to download the latest version of malaria-profiler from GitHub and install into our new environment. Remember to first activate the environment before running the install command:</p> <pre><code>conda activate malaria-profiler\n</code></pre> <p>We can now install the pathogen-profiler and malaria-profiler tools from GitHub:</p> <pre><code>pip install --force-reinstall git+https://github.com/jodyphelan/pathogen-profiler.git@dev\npip install --force-reinstall git+https://github.com/jodyphelan/malaria-profiler.git@dev\n</code></pre> <p>Check the installation has run correctly by typing in the following into your terminal:</p> <pre><code>malaria-profiler --help\n</code></pre> <p>You should see the following text:</p> <p>Terminal</p> <pre><code>Usage: malaria-profiler [-h] [--version] [--no_cleanup] [--logging {DEBUG,INFO,WARNING,ERROR,CRITICAL}] {profile,collate,update_db,create_resistance_db,create_species_db,list_db} ...\n\nmalaria-profiler pipeline\n\nPositional Arguments:\n{profile,collate,update_db,create_resistance_db,create_species_db,list_db}\n                        Task to perform\n    profile             Run whole profiling pipeline\n    collate             Collate results form multiple samples together\n    update_db           Update all databases\n    create_resistance_db\n                        Generate the files required to run resistance profiling with malaria-profiler\n    create_species_db   Generate the files required to run speciation with malaria-profiler\n    list_db             List loaded databases\n\nOptions:\n-h, --help            show this help message and exit\n--version             show program's version number and exit\n--no_cleanup          Don't remove temporary files on error (default: False)\n--logging {DEBUG,INFO,WARNING,ERROR,CRITICAL}\n                        Logging level (default: info)       \n</code></pre> <p>You should see several subcommands that you can run with malaria-profiler. For example, we will be using the <code>profile</code> subcommand to analyze the genomes of the P. falciparum isolates in our dataset. If you want to learn more about the options available for a specific subcommand, you can run <code>malaria-profiler &lt;subcommand&gt; --help</code>. For example, to learn more about the options available for the <code>profile</code> subcommand, you can run <code>malaria-profiler profile --help</code>.</p> <p>Finally, we need to download the latest databases that malaria-profiler will use. These include reference genomes, mutation lists and machine learning models of geographic prediction. You can do this running the following command:</p> <pre><code>malaria-profiler update_db\n</code></pre> <p>To see the latest versions of databases that you have, use the <code>list_db</code> subcommand. </p> <p>Question</p> <p>Which species can malaria-profiler analyse?</p> <p>Let's first see how to run malaria-profiler. Move into the directory called <code>results</code>, this is where we will generate our results. First let's see how many fastq files we have. There are two fastq files for each sample, representing the forward and reverse reads. We have a total of 9 samples, so we should have 18 fastq files in total. We can check this by running the following command:</p> <pre><code>ls ../fastq/ | wc -l\n</code></pre> <p>To make the analysis faster, we have subset the fastqs to only contain reads overlapping drug resistance genes and other important regions of the genome used by malaria-profiler. We can see the regions that are included in the fastq files by looking at the <code>regions.bed</code> file. This file contains the coordinates of the regions that were extracted from the full genome. We can look at the first few lines of this file by running the following command:</p> <pre><code>head ../data_files/regions.bed\n</code></pre> <p>You should see something like this:</p> <p>Terminal</p> <pre><code>Pf3D7_01_v3 190069  201430\nPf3D7_01_v3 380497  382624\nPf3D7_01_v3 489336  489337\nPf3D7_02_v3 305437  305438\nPf3D7_02_v3 367270  367271\nPf3D7_02_v3 375426  375427\nPf3D7_03_v3 221112  223145\nPf3D7_03_v3 383168  383169\nPf3D7_03_v3 617425  617426\nPf3D7_03_v3 619608  619609\n</code></pre> <p>Next, we will run malaria-profiler on the fastq files to profile the P. falciparum isolates. We will use the <code>profile</code> subcommand of malaria-profiler to do this. The <code>profile</code> subcommand takes as input the fastq files for each sample and the regions.bed file. It will then align the reads to the reference genome, call variants, and predict drug resistance and geographic origin. We will also specify the output directory where the results will be saved. We can run the following command to profile the isolate with the accession code SRR22672119:</p> <pre><code>malaria-profiler profile -1 ../fastq/SRR22672119_1.fq.gz -2 ../fastq/SRR22672119_2.fq.gz -p SRR22672119 --resistance_db falciparum --txt -t 4\n</code></pre> <p>There are a few important parameters that you'll notice in the command above:</p> <ul> <li><code>-1</code> and <code>-2</code> specify the paths to the forward and reverse fastq files for the sample</li> <li><code>-p</code> specifies the prefix to use for the output files</li> <li><code>--resistance_db</code> specifies the database to use for drug resistance prediction. In this case, we are using the <code>falciparum</code> database, which contains information about drug resistance mutations in P. falciparum.</li> <li><code>--txt</code> specifies that we want the results in text format. By default, the results are saved in JSON format.</li> <li><code>-t</code> specifies the number of threads to use for the analysis. We are using 4 threads in this case (if you have access to more you can increase this number to speed up the analysis).</li> </ul> <p>After running the command, you should have the following files:</p> <ul> <li><code>SRR22672119.bam</code>: The aligned reads in BAM format</li> <li><code>SRR22672119.bam.bai</code>: The index file for the aligned reads</li> <li><code>SRR22672119.results.json</code>: The results of the profiling analysis in JSON format</li> <li><code>SRR22672119.results.txt</code>: The results of the profiling analysis in text format</li> </ul> <p>You can view the results in the text file by running the following command:</p> <pre><code>cat SRR22672119.results.txt\n</code></pre> <p>Question</p> <p>What is the predicted geographic origin of the isolate with the accession code SRR22672119? Does this make sense with regards to where the sample was isolated from?</p> <p>Question</p> <p>What drug resistance mutations were detected in the isolate with the accession code SRR22672119?</p> <p>Now that we have profiled one isolate, we can run malaria-profiler on the remaining isolates in the dataset. We can do this by writing a command that runs the <code>profile</code> subcommand for each sample. For this purpose we will use a powerful tool called <code>parallel</code>. This tool allows us to run multiple commands in parallel, which can speed up the analysis significantly. Parallel is a super useful tool which you can use to automate running of commands. For example lets say you have some fastQ data for 100 samples and you need to run the same command for all of them. Parallel will help by 1) allowing you to write a general template for the command which it will run for all the samples and 2) handleing the job queue and allowing you to run the commands in parallel (hence the name!). We can supply our values of to parallel using stdin, i.e. by printing the values and passing them to parallel using a <code>|</code> symbol. Then we need to tell parallel to do something with the values it receives. You can can see we have replace the x values with the symbols {}. This is a kind of place holder value which parallel will replace for each line with the value of the line. Finally the <code>-j 1</code> flag tells parallel to run 1 job at a time (you can change this if you have more cores available).</p> <p>We will use the following command to run malaria-profiler on all the isolates in the dataset:</p> <pre><code>ls ../fastq/ | grep _1.fq.gz | sed 's/_1.fq.gz//' &gt; sample_names.txt\ncat sample_names.txt  | parallel -j 1 --bar malaria-profiler profile -1 ../fastq/{}_1.fq.gz -2 ../fastq/{}_2.fq.gz -p {} --resistance_db falciparum --txt -t 4\n</code></pre> <p>The first command will list all the fastq files in the <code>fastq</code> directory, extract the sample names, and save them to a file called <code>sample_names.txt</code>. The second command will read the sample names from the file and run the <code>profile</code> subcommand for each sample using parallel. You should see a progress bar as the analysis runs. Once the analysis is complete, you should have results files for all the isolates in the current directory.</p> <p>Question</p> <p>Have a look at some of the other result files as you have done before. Do they look similar?</p>"},{"location":"#collating-results","title":"Collating results","text":"<p>Now that we have run malaria-profiler on all the fastq files, we can collate the results to compare the drug resistance profiles and geographic origins of the isolates. We can use the <code>collate</code> subcommand of malaria-profiler to do this. The <code>collate</code> subcommand takes as input the results files for each sample and collates them into a single file. We can run the following command to collate the results for all the isolates:</p> <pre><code>malaria-profiler collate \n</code></pre> <p>The command should automatically detect all the results files in the current directory and collate them into a single file called <code>malaria-profiler.collate.txt</code>. You can view the collated results by running the following command:</p> <pre><code>less malaria-profiler.collate.txt\n</code></pre> <p>You should see a table with the following columns:</p> <ul> <li>id - The sample ID</li> <li>species - The predicted species of the sample. In our case this will just be P. falciparum as we have specified the database to use for drug resistance prediction.</li> <li>geographic_source - The predicted geographic origin of the sample</li> <li>geographic_source_proba - The probability of the predicted geographic origin</li> <li>median_target_depth - The median depth of coverage for the target regions</li> <li>missing_positions - A boolean flag indicating whether any drug resistance positions are missing sufficient depth</li> <li>chloroquine - The predicted resistance profile for chloroquine</li> <li>pyrimethamine - The predicted resistance profile for pyrimethamine</li> <li>sulfadoxine - The predicted resistance profile for sulfadoxine</li> </ul> <p>Question</p> <p>What is the predicted geographic origin of the isolates in the dataset? Do they all align with the known origins of the samples?</p> <p>Question</p> <p>Are there any isolates with missing drug resistance positions?</p> <p>Question</p> <p>What drug resistance mutations are present in the isolates?</p> <p>Another file is also generated called <code>malaria-profiler.collate.txt.variants.csv</code>. This file contains the variants that were called in the target regions for each sample. You can view the variants by running the following command:</p> <pre><code>less malaria-profiler.collate.txt.variants.csv\n</code></pre> <p>You should see a table with the following columns:</p> <ul> <li>sample - The sample ID</li> <li>gene_name - The name of the gene containing the variant</li> <li>change - The change in the gene caused by the variant</li> <li>freq - The frequency of the variant in the raw data</li> <li>type - The type of variant (e.g., SNP, insertion, deletion)</li> </ul> <p>There is a lot of information to take in here an although it is possible to analyse with command-line software, it is often easier to use a more visual tool like R to analyse the data. We will now move to R to analyse the data.</p>"},{"location":"#analysing-the-results","title":"Analysing the results","text":"<p>Now we are ready to analyse the results of the malaria-profiler analysis. We will use the results to identify drug resistance mutations in the P. falciparum isolates and compare the geographic origins of the samples. We will do this in R so open up an R session by typing <code>R</code> into the terminal.</p> <p>For those who are familliar with R, have a go at answering the following questions. Try answer them using the skills you have learned so far in the course before moving on. If you are not familliar with R, don't worry, in the next section we go through how to do this.</p> <p>Question</p> <p>What is the average coverage of the targets in the dataset? Are there any samples with low coverage?</p> <p>Question</p> <p>Which mutations do you find at &gt;5% in the dataset? Do these numbers align with what you find from the publications?</p> <p>Question</p> <p>Do you find any mutations in the Kelch13 gene? Does your list differ from those presented in the publication?</p> <p>Question</p> <p>What is the distribution of the predicted geographic origins of the isolates? Are there any isolates with uncertain geographic origins?</p> <p>With these questions remember that not all samples might be of the same quality. </p> <p>For those of you who are not very familiar with R, it is a powerful statistical programming language that is widely used for data analysis and visualization. We will be using the <code>dplyr</code> package, which provides a set of tools for working with data frames, and the <code>ggplot2</code> package, which provides a set of tools for creating plots and visualizations. These packages along with R itself were installed with conda when we created the environment for malaria-profiler.</p>"},{"location":"#loading-the-data","title":"Loading the data","text":"<p>Let's first load the <code>dplyr</code> and <code>ggplot2</code> packages in R:</p> <pre><code>library(dplyr)\nlibrary(ggplot2)\n</code></pre> <p>Now we will go ahead and load the collated results file into R. We can do this by reading the file into a data frame using the <code>read.table</code> function. We will then use the <code>head</code> function to view the first few rows of the data frame:</p> <pre><code>df_collate_raw&lt;-read.table(\"malaria-profiler.collate.txt\", header = TRUE, sep = \"\\t\")\nhead(df_collate_raw)\n</code></pre>"},{"location":"#quality-control","title":"Quality control","text":"<p>Now let's have a look at the depth of coverage across the targets. You can use the <code>summary</code> function for this:</p> <pre><code>summary(df_collate_raw$median_target_depth)\n</code></pre> <p>A more visual way to look at the coverage is to plot a histogram of the coverage values. We can do this using the <code>ggplot</code> function from the <code>ggplot2</code> package. We will use the <code>geom_histogram</code> function to create the histogram. We can also add a title and labels to the plot using the <code>ggtitle</code> and <code>labs</code> functions. We can run the following code to create the histogram:</p> <pre><code>ggplot(df_collate_raw, aes(x = median_target_depth)) +\n  geom_histogram(binwidth = 10, fill = \"skyblue\", color = \"black\") +\n  ggtitle(\"Distribution of median target depth\") +\n  labs(x = \"Median target depth\", y = \"Frequency\")\n</code></pre> <p></p> <p>Another way to look for samples thay might need to be excluded is to look at the missing positions. We can do this by counting the number of samples with missing positions using the <code>table</code> function:</p> <pre><code>table(df_collate_raw$missing_positions)\n</code></pre> <p>Do you think there is any relationship between the coverage and the missing positions? We can explore this by creating a box plot of the coverage values for samples with and without missing positions. We can do this using the <code>geom_boxplot</code> function from the <code>ggplot2</code> package. We can run the following code to create the box plot:</p> <pre><code>ggplot(df_collate_raw, aes(x = missing_positions, y = median_target_depth)) +\n  geom_boxplot(fill = \"skyblue\", color = \"black\") +\n  ggtitle(\"Coverage by missing positions\") +\n  labs(x = \"Missing positions\", y = \"Median target depth\")\n</code></pre> <p></p> <p>Question</p> <p>Do you think we should exclude any samples from the analysis based on coverage?</p> <p>Let's remove the samples with missing positions from the dataset. We can do this by filtering the data frame using the <code>filter</code> function from the <code>dplyr</code> package. We will create a new data frame called <code>df_collate</code> that contains only the samples with no missing positions:</p> <pre><code>df_collate&lt;-df_collate_raw %&gt;% \n  filter(missing_positions==\"False\")\n</code></pre>"},{"location":"#drug-resistance-mutations","title":"Drug resistance mutations","text":"<p>Now that we have filtered the data frame, let's look at the drug resistance mutations in the dataset. We can start by looking at the mutations that are present in the dataset. To do this it is probably better to load the \"long format\" of the data. This is where each row represents a single mutation. As you might remember, this is the format that the <code>malaria-profiler.collate.txt.variants.csv</code> file is in. We can load this file into R using the <code>read.csv</code> function and then use the <code>head</code> function to view the first few rows of the data frame:</p> <pre><code>df_variants_raw&lt;-read.csv(\"malaria-profiler.collate.txt.variants.csv\")\nhead(df_variants_raw)\n</code></pre> <p>Remember we might have to filter this table to only include samples which pass our criteria from above. Additionally, there are more factors to consider. If you go to the methods section of the publication you will see that they have filtered the data based on the frequency of the mutations. This is because some mutations are present in the population at a low frequency and may be the result of a PCR or sequencing error. First let's visualise the frequency of the mutations in the dataset. We can do this by creating a histogram of the frequency values. We can use the <code>geom_histogram</code> function from the <code>ggplot2</code> package to create the histogram. We can run the following code to create the histogram:</p> <pre><code>ggplot(df_variants_raw, aes(x = freq)) +\n  geom_histogram(binwidth = 0.01, fill = \"skyblue\", color = \"black\") +\n  ggtitle(\"Distribution of mutation frequency\") +\n  labs(x = \"Frequency\", y = \"Frequency\")\n</code></pre> <p></p> <p>Or if you prefer a text output you can use the <code>summary</code> function:</p> <pre><code>summary(df_variants_raw$freq)\n</code></pre> <p>Question</p> <p>What frequency cut-off would you use to filter the mutations in the dataset? Do you think this is a reasonable cut-off?</p> <p>You should see the majority of the mutations have a frequency close to 1, meaning they are present in almost all of the reads within the samples. Then there are a few mutations uniformly distributed between 0.4 and 0.9. </p> <p>Question</p> <p>You should also notice that there are no mutations with a frequency less than 0.4. Can you think of a reason why this might be the case? Have a look at the help text for the <code>malaria-profiler</code> tool to see if you can find any information on this. You can do this by running the following command:</p> <pre><code>malaria-profiler profile --help\n</code></pre> <p>You should see the following text: <pre><code>Variant Filtering Options:\n--depth DEPTH         Minimum depth hard and soft cutoff specified as comma separated values (default: 0,10)\n--af AF               Minimum allele frequency hard and soft cutoff specified as comma separated values (default: 0.1,0.4)\n--strand STRAND       Minimum read number per strand hard and soft cutoff specified as comma separated values (default: 0,3)\n--sv_depth SV_DEPTH   Structural variant minimum depth hard and soft cutoff specified as comma separated values (default: 0,10)\n--sv_af SV_AF         Structural variant minimum allele frequency hard cutoff specified as comma separated values (default: 0.5,0.9)\n--sv_len SV_LEN       Structural variant maximum size hard and soft cutoff specified as comma separated values (default: 100000,50000)\n</code></pre></p> <p>The --af flag specifies the minimum allele frequency hard and soft cutoffs. The default values are 0.1 and 0.4, respectively. This means that by default, malaria-profiler will filter out mutations with a frequency less than 0.4. Any variant with less than 0.1 in frequency will not be analysed. Anything between 0.1 and 0.4 will be kept in the report but will be flagged as a failing the soft cutoff. This allows the user to decide if they want to keep these variants or not. By default, none of these \"soft fail\" variant make it into the final collated reports and this is why we do not see any mutations with a frequency less than 0.4 in the dataset.</p> <p>Another thing to consider is the type of mutation. We can look at the distribution of mutation types in the dataset by using the <code>table</code> function:</p> <pre><code>table(df_variants_raw$type)\n</code></pre> <p>For the purposes of this tutorial we will retain only missense mutations. We can combine the sample qc and type filters into one single command to create a filtered dataset:</p> <pre><code>low_qc_samples&lt;-df_collate_raw$id[df_collate_raw$missing_positions==\"True\"]\n\ndf_variants &lt;- df_variants_raw %&gt;%\n  filter(type=='missense_variant') %&gt;%\n  filter(!sample %in% low_qc_samples)\n</code></pre> <p>We can now investigate the frequency of the mutations in our dataset. First we can use the <code>count</code> function to count the number of mutations for each gene:</p> <pre><code>counts_table&lt;-count(df_variants,gene_name,change) %&gt;% arrange(-n)\n</code></pre> <p>We can then use the <code>head</code> function to view the top 10 mutations in the dataset:</p> <pre><code>head(counts_table,10)\n</code></pre> <p>Question</p> <p>What are the top 10 mutations in the dataset? Do these mutations align with what you would expect to see in P. falciparum isolates?</p> <p>Let's get the percentage of samples that have each mutation. We can do this by counting the number of samples that have each mutation and dividing by the total number of samples. We can add a new column into the <code>counts_table</code> data frame that contains the percentage of samples that have each mutation:</p> <pre><code>n_samples&lt;-nrow(df_collate)\ncounts_table&lt;-counts_table %&gt;% \n  mutate(percentage = n/n_samples*100)\n</code></pre> <p>Now we can plot the percentage of samples that have each mutation with a histogram. We can use the <code>geom_histogram</code> function from the <code>ggplot2</code> package to create the histogram. We can run the following code to create the histogram:</p> <pre><code>ggplot(counts_table, aes(x = percentage)) +\n  geom_histogram(binwidth = 1, fill = \"skyblue\", color = \"black\") +\n  ggtitle(\"Distribution of mutation frequency\") +\n  labs(x = \"Percentage of samples\", y = \"Frequency\")\n</code></pre> <p></p> <p>Now let's plot that by gene. We can use the <code>facet_wrap</code> function to create a separate plot for each gene. We can run the following code to create the plot:</p> <pre><code>ggplot(counts_table, aes(x = percentage)) +\n  geom_histogram(binwidth = 1, fill = \"skyblue\", color = \"black\") +\n  ggtitle(\"Distribution of mutation frequency by gene\") +\n  labs(x = \"Percentage of samples\", y = \"Frequency\") +\n  facet_wrap(~gene_name, scales = \"free\") +\n  xlim(0,110) \n</code></pre> <p></p> <p>Question</p> <p>What is the distribution of the frequency of mutations by gene? Are there any genes with mutations that are present in a high percentage of samples? Are all mutations relevant for drug resistance?</p> <p>Kelch13 is a gene that is associated with artemisinin resistance in P. falciparum. Let's look at the mutations in the Kelch13 gene in the dataset. We can filter the data frame to only include mutations in the Kelch13 gene and then use the <code>count</code> function to count the number of mutations for each mutation in the gene. We can run the following code to do this:</p> <pre><code>df_kelch13&lt;-df_variants %&gt;% \n  filter(gene_name==\"K13\")\n</code></pre> <p>Do any of these mutations align with the mutations that are known to be associated with artemisinin resistance in P. falciparum? Have a look below at the mutations that are known to be associated with artemisinin resistance. This information can be found in the WHO publication on the surveillance of antimalarial drug resistance \"Report on antimalarial drug efficacy, resistance and response\" and is shown below.</p> <p></p>"},{"location":"#geographic-origins","title":"Geographic origins","text":"<p>Finally, let's look at the geographic origins of the isolates in the dataset. We can start by counting the number of samples from each geographic origin. We can do this using the <code>table</code> function:</p> <pre><code>table(df_collate$geographic_source)\n</code></pre> <p>Question</p> <p>You might notice that there are a few samples which have been classified as originating from Central Africa. This is a bit strange as the samples were collected from Mozambique. Can you think why this might be?</p> <p>It might help if we bring in the probabilities of the predictions. Let's create a box plot of the probabilities of the geographic origins for each sample. We can use the <code>geom_boxplot</code> function from the <code>ggplot2</code> package to create the box plot. We can run the following code to create the box plot:</p> <pre><code>ggplot(df_collate, aes(x = geographic_source, y = geographic_source_proba)) +\n  geom_boxplot(fill = \"skyblue\", color = \"black\") +\n  ggtitle(\"Probabilities of geographic origins\") +\n  labs(x = \"Geographic origin\", y = \"Probability\")\n</code></pre> <p>You should be able to see that the samples that have been classified as originating from Central Africa have a relative lower probability on average than those classified as Eastern Africa. This is a good example of why it is important to consider the probabilities of the predictions when interpreting the results and may hint at some issues/explanations. </p>"},{"location":"#complex-infection-analysis","title":"Complex infection analysis","text":"<p>Next we will merge in the multiplicity of infection data we generated using pyMoi. First we need to install it in a similar way to how we did for malaria-profiler, using pip to download the latest version from GitHub and install it into our environment. Remember to activate the environment before running the install command:</p> <p>Important</p> <p>Keep your R shell open, we will be using it again in the next section. You can open a new terminal window to run the following commands.</p> <pre><code>conda activate malaria-profiler\npip install --force-reinstall git+https://github.com/jodyphelan/pyMOI.git\n</code></pre> <p>Check the installation has run correctly by typing in the following into your terminal:</p> <pre><code>pymoi --help\n</code></pre> <p>You should see the following text:</p> <p>terminal output</p> <pre><code>usage: pymoi [-h] --bam BAM --vcf VCF --outfile OUTFILE [--maxdist MAXDIST] [--min-count MIN_COUNT] [--min-frac MIN_FRAC]\n\nA simple command line tool for Moi\n\noptions:\n-h, --help            show this help message and exit\n--bam BAM             BAM (or cram) file (default: None)\n--vcf VCF             VCF file (default: None)\n--outfile OUTFILE     Name of output file (default: None)\n--maxdist MAXDIST     Maximum distance between the first and last SNP (default: 500)\n--min-count MIN_COUNT\n                        Minimum count of haplotype (default: 10)\n--min-frac MIN_FRAC   Minimum fraction of haplotype of the total number of reads at the site (default: 0.1)\n</code></pre> <p>Go to where you have the bam files from malaria-profiler. To run pymoi we first need to perform variant calling. We will use <code>freebayes</code> to do this. We can do this by running the following command. For example:</p> <pre><code>freebayes -f ../reference/falciparum.fasta SRR22672119.bam --targets ../data_files/hypervariable.bed | bcftools view -Oz -o SRR22672119.vcf.gz\ntabix SRR22672119.vcf.gz\n</code></pre> <p>We then run the following <code>pymoi</code> command to generate the multiplicity of infection data by supplying the bam file and the vcf file. For example:</p> <pre><code>pymoi --bam SRR22672119.bam --vcf SRR22672119.vcf.gz --outfile SRR22672119.pymoi.json\n</code></pre> <p>This will run the pymoi tool on the bam file and the vcf file and generate a json file with the multiplicity of infection data. You can view the results by running the following command:</p> <pre><code>cat SRR22672119.pymoi.json\n</code></pre> <p>Question</p> <p>Try to run it on a few of the other samples. What do results do you get?</p> <p>We have generated the multiplicity of infection data for all the samples in the dataset which we can merge into our collated results. This data is stored in the <code>results/moi.csv</code> file. We can load this data into R using the <code>read.csv</code> function and then use the <code>head</code> function to view the first few rows of the data frame:</p> <pre><code>df_moi&lt;-read.csv(\"moi.csv\")\nhead(df_moi)\n</code></pre> <p>Now we can merge the multiplicity of infection data with the collated results data. We can do this using the <code>merge</code> function in R. We will merge the data frames on the <code>id</code> column, which contains the sample IDs. We can run the following code to merge the data frames:</p> <pre><code>df_collate_moi&lt;-merge(df_collate, df_moi, by = \"id\")\n</code></pre> <p>We can also now merge information about the location of the samples. This data is stored in the <code>results/locations.csv</code> file. We can load this data into R using the <code>read.csv</code> function and then use the <code>head</code> function to view the first few rows of the data frame:</p> <pre><code>df_locations&lt;-read.csv(\"../data_files/locations.csv\")\nhead(df_locations)\n</code></pre> <p>Now we can merge the location data with the collated results data. We can do this using the <code>merge</code> function in R. We will merge the data frames on the <code>id</code> column, which contains the sample IDs. We can run the following code to merge the data frames:</p> <pre><code>df_collate_moi_loc&lt;-merge(df_collate_moi, df_locations, by = \"id\")\n</code></pre> <p>Let's see if there is any difference between the different regions in terms of the multiplicity of infection. We can create a box plot of the multiplicity of infection values for each region. We can use the <code>geom_boxplot</code> function from the <code>ggplot2</code> package to create the box plot. We can run the following code to create the box plot:</p> <pre><code>ggplot(df_collate_moi_loc, aes(x = region, y = moi)) +\n  geom_boxplot(fill = \"skyblue\", color = \"black\") +\n  ggtitle(\"Multiplicity of infection by region\") +\n  labs(x = \"Region\", y = \"Multiplicity of infection\")\n</code></pre> <p>Another way to view this is with a bar plot. We can use the <code>geom_bar</code> function from the <code>ggplot2</code> package to create the bar plot. We can run the following code to create the bar plot:</p> <pre><code>ggplot(df_collate_moi_loc, aes(x = region, fill = factor(moi))) +\n  geom_bar(position = \"dodge\") +\n  ggtitle(\"Multiplicity of infection by region\") +\n  labs(x = \"Region\", y = \"Multiplicity of infection\")\n</code></pre> <p>Question</p> <p>What is the distribution of the multiplicity of infection values by region? Are there any differences in the multiplicity of infection values between the regions?</p> <p>Finally, let's look at the median target depth by multiplicity of infection. We can create a box plot of the median target depth values for each multiplicity of infection value. We can use the <code>geom_boxplot</code> function from the <code>ggplot2</code> package to create the box plot. We can run the following code to create the box plot:</p> <pre><code>ggplot(df_collate_moi_loc, aes(x = factor(moi), y = median_target_depth)) +\n  geom_boxplot(fill = \"skyblue\", color = \"black\") +\n  ggtitle(\"Median target depth by multiplicity of infection\") +\n  labs(x = \"Multiplicity of infection\", y = \"Median target depth\")\n</code></pre> <p>Question</p> <p>What is the distribution of the median target depth values by multiplicity of infection? Are there any differences in the median target depth values between the multiplicity of infection values?</p>"},{"location":"#summary","title":"Summary","text":"<p>In this practical, we have used malaria-profiler to profile P. falciparum isolates from a dataset of WGS data. We have analyzed the drug resistance mutations and geographic origins of the isolates and compared the results to the known origins of the samples. We have also used R to analyze the results and identify drug resistance mutations in the isolates. We have also merged in the multiplicity of infection data and analyzed the multiplicity of infection values by region. We have seen that the multiplicity of infection values can vary between regions and that there are differences in the median target depth values between the multiplicity of infection values.</p> <pre><code>export RSTUDIO_WHICH_R=/opt/conda/envs/malaria-profiler/bin/R\n</code></pre>"}]}